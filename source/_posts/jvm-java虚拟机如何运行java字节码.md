---
title: jvm-java虚拟机如何运行java字节码
tags: jvm
password: jvm
abbrlink: 11284
date: 2018-09-26 10:37:53
---

**参考：《深入拆解Java虚拟机》 ---------- 极客时间**

# Java与c语言运行差别

### JRE和JDK的区别

JRE: Java代码可以在开发工具中运行，可以双击jar文件执行，也可以在命令行中执行，网页中同样可以运行Java代码，这些都需要JRE，也就是Java运行时环境。

JDK: JRE仅仅包含运行Java代码的必须组件，包括Java虚拟机以及Java核心类库，程序员经常接触的JDK(Java开发工具包)同样包含JRE，同时附带一系列开发

### C语言程序编译结果

```
; 最左列是偏移；中间列是给机器读的机器码；最右列是给人读的汇编代码
0x00:  55                    push   rbp
0x01:  48 89 e5              mov    rbp,rsp
0x04:  48 83 ec 10           sub    rsp,0x10
0x08:  48 8d 3d 3b 00 00 00  lea    rdi,[rip+0x3b] 
                                    ; 加载 "Hello, World!\n"
0x0f:  c7 45 fc 00 00 00 00  mov    DWORD PTR [rbp-0x4],0x0
0x16:  b0 00                 mov    al,0x0
0x18:  e8 0d 00 00 00        call   0x12
                                    ; 调用 printf 方法
0x1d:  31 c9                 xor    ecx,ecx
0x1f:  89 45 f8              mov    DWORD PTR [rbp-0x8],eax
0x22:  89 c8                 mov    eax,ecx
0x24:  48 83 c4 10           add    rsp,0x10
0x28:  5d                    pop    rbp
0x29:  c3                    ret
```

c语言程序编译之后，就是机器码，为了方便开发人员理解，可以反汇编，转换成汇编代码

### Java为什么需要在虚拟机中运行

Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。

当前的主流思路是这样子的，设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。 Java 字节码指令的操作码（opcode）固定为一个字节。

### Java程序反编译结果

```
# 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码
0x00:  b2 00 02         getstatic java.lang.System.out
0x03:  12 03            ldc "Hello, World!"
0x05:  b6 00 04         invokevirtual java.io.PrintStream.println
0x08:  b1               return
```

我们可以看到C语言类似，反编译之后也是一个一个的字节码，不同的是结果更加精简，更容易阅读，Java虚拟机相对于物理机而言，抽象程度更高。

Java虚拟机可以由硬件实现，也可以有软件实现，这样一旦程序被转换成字节码，将可以在不同平台上的虚拟机运行，也就是**一次编写，到处运行**。托管环境还提供了诸如自动内存管理与垃圾回收，数组越界、动态类型、安全权限等等的动态检查，避免了一些业务无关的代码。

# Java如何运行Java字节码

以HotSpot虚拟机为例,从虚拟机和底层硬件两个角度来看:

虚拟机角度:

虚拟机首先需要将编译成成class文件加载到Java虚拟机中，加载后的Java类会存放在方法区**Method area**中，实际运行时，虚拟机会执行方法区内的代码。

类似于X86，Java虚拟机同样会在内存中分配出堆和栈来存储运行时的数据。不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。

![](/assets/jvm/ab5c3523af08e0bf2f689c1d6033ef77.png)

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

硬件角度:

Java字节码无法直接运行，Java虚拟机需要将Java字节码翻译成机器码。

在HotSpot中，翻译方式有两种，1. 解释执行，逐条将字节码翻译成机器码并执行 2. 即时编译（Just-In-Time compilation, JIT）,即将一个方法中包含的所有字节码变异成机器码后运行。

![](/assets/jvm/5ee351091464de78eed75438b6f9183b.png)

解释执行: 类似于python,php等。优势:无需等待编译

JIT: 实际运行速度更快

HotSpot默认采用混合模式，综合二者的邮电，首先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

# Java虚拟机运行效率如何

HotSpot采用多种技术来提高**启动性能**以及**峰值性能**。即时编译即为其中最重要的技术之一。该技术建立在二八定律上，也就是20%的代码占据%80的计算资源。

理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且能够根据这个信息做出相应的优化。

比如：我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。

为了满足不同用户的场景的需要，HotSpot内置多个即时编译器：C1，C2和Graal。Graal是Java 10引入的实验性即时编译器。之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。

C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。

C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。

在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。





